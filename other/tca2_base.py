#=============================================================================
# Helper script for analysis - using LCOV - code coverage result generated by 
# the gcc compiler
#=============================================================================
#
usage = """ 
(T)est (C)overage (A)nalyzer 2
===============================================================================
Usage: tca2 [options] sum    [<filter-file>]
       tca2 [options] view   [<filter-file>]
       tca2 [options] ci     [<filter-file>]
       tca2 [options] ciview [<filter-file>]

Arguments:
  sum              Generates a summary report of the code coverage.  A detailed 
                   HTML report is generated in the current working directory.
  view             Same as the 'sum' command but 'launches' the HTML report 
                   instead of displaying a summary.
  ci               Generates a detailed HTML coverage report to be published
                   as part of a CI/CD pipeline.
  ciview           Same as the 'ci' command but also 'launches' the HTML report

  <filter-file>    Specifies a JSON file that contains list of LCOV 'extract'
                   and 'remove' patterns.  The default is filter for current
                   build directory.

Options:
  --in-dir DIR     The 'input' directory to use for the code coverage
                   analysis. [Default: .]
  --html-dir DIR   The name of directory to output HTML reports. 
                   [Default: .html-report]
                   is a work-around for Jenkins-Cobertura plugin
  --line-hi NUM    The threshold 'hi-limit' for line coverage metrics.
                   [Default: 80]
  --line-med NUM   The threshold 'med-limit' for line coverage metrics.
                   [Default: 75]
  --br-hi NUM      The threshold 'hi-limit' for branch coverage metrics.
                   [Default: 60]
  --br-med NUM     The threshold 'med-limit' for branch coverage metrics.
                   [Default: 50]
  --test-dir DIR   The unit test directory name [Default: _0test/]
  -v, --verbose    Verbose output.
  -h, --help       Display command help.
        
         

NOTES:
    o TCA2 assumes you used the gcc compiler to create your executable.
    o When compiling you must use the following options:
        '-fprofile-arcs -ftest-coverage'
    o When linking you must use the following options:
        '-fprofile-arcs -lgcov'
    o You must first run your executable BEFORE running TCA2
    o You have `lcov`, `genhtml`, and 'gcovr' installed on your system.

"""
#
import os, sys, platform
from nqbplib.docopt.docopt import docopt
from . import utils2

VERBOSE_ONLY    = True
verbose_enabled = False
LCOV_OPTS       = '--rc branch_coverage=1 --rc geninfo_unexecuted_blocks=1  --ignore-errors mismatch'
LCOV_OFILE      = '.coverage.info'
GENHTML_OPTS    = '--branch-coverage --no-function-coverage'

#------------------------------------------------------------------------------
# Parse command line
def run( prj_dir, argv):
    # Process command line args...
    args = docopt(usage, version="0.0.1")
    global verbose_enabled
    verbose_enabled = args['--verbose']

    # Default line/statement filter
    line_regex_filters = ['.*KIT_SYSTEM_ASSERT.*', ".*KIT_SYSTEM_TRACE.*"]
    # TODO: If <filter-file> specific -->update 'line_filters'

    # get the package root
    pkg = os.environ.get('NQBP_PKG_ROOT')

    # Capture code coverage metrics
    capture_metrics( args['--in-dir'], LCOV_OFILE, line_regex_filters )

    # Generate report
    if args['sum']:
        # Default filter pattern
        if not args['<filter-file>']:
            generate_unit_test_report( pkg, prj_dir, args )
            print_summary( LCOV_OFILE )

    # Generate and view HTML
    elif args['view'] :
        # Generate HTML report
        generate_unit_test_report( pkg, prj_dir, args, [args['--test-dir']] )
        generate_html_report( LCOV_OFILE, args['--html-dir'], args )

        # View HTML report
        html_index_path = f'{args["--html-dir"]}/index.html'
        open_html_in_browser( html_index_path )

    # Generate for CI
    elif args['ci'] or args['ciview']:
        # Generate HTML report
        generate_unit_test_report( pkg, prj_dir, args, [args['--test-dir'], "xpkgs/", "_support/"] )
        generate_html_report( LCOV_OFILE, args['--html-dir'], args )

        if args['ciview']:
            # View HTML report
            html_index_path = f'{args["--html-dir"]}/index.html'
            open_html_in_browser( html_index_path )

#------------------------------------------------------------------------------
def generate_unit_test_report( pkg, prj_dir, args, remove_list ):
    dir_under_test = derive_unit_test_dir(pkg, prj_dir, args['--test-dir'])
    extract_metrics( LCOV_OFILE, LCOV_OFILE, dir_under_test )
    remove_metrics( LCOV_OFILE, LCOV_OFILE, remove_list )

def capture_metrics( srcdir, outfile, filter_lines=None  ):
    xlines = ""
    if filter_lines:
        xlines = f" --omit-lines '{'|'.join(filter_lines)}'"
    cmd = f'{lcov()} --ignore-errors unused {xlines} -c -d {srcdir} {LCOV_OPTS} -o {outfile}'
    print_output( cmd, VERBOSE_ONLY )
    (r, text) = utils2.run_shell( cmd )
    if r != 0:
        sys.exit(text)

def extract_metrics( srcfile, outfile, filter_pattern ):
    cmd = f'{lcov()} -e {srcfile} {filter_pattern} {LCOV_OPTS} -o {outfile}'
    print_output( cmd, VERBOSE_ONLY )
    (r, text) = utils2.run_shell( cmd )
    if r != 0:
        sys.exit(text)


def remove_metrics( srcfile, outfile, filter_files):
    cmd = f'{lcov()} --ignore-errors unused -r {srcfile} {" ".join(filter_files)} {LCOV_OPTS} -o {outfile}'
    print_output( cmd, VERBOSE_ONLY )
    (r, text) = utils2.run_shell( cmd )
    if r != 0:
        sys.exit(text)

# def omit_lines( srcfile, outfile, filter_pattern ):
#     cmd = f'{lcov()} {LCOV_OPTS} --ignore-errors unused --omit-lines {filter_pattern} -l {srcfile} -o {outfile}'
#     print_output( cmd, VERBOSE_ONLY )
#     (r, text) = utils2.run_shell( cmd )
#     if r != 0:
#         sys.exit(text)

def generate_html_report( srcfile, html_dir, args ):
    limits = " ".join([
        f'--rc genhtml_line_hi_limit={args["--line-hi"]}',
        f'--rc genhtml_line_med_limit={args["--line-med"]}',
        f'--rc genhtml_branch_hi_limit={args["--br-hi"]}',
        f'--rc genhtml_branch_med_limit={args["--br-med"]}',
        f'--rc genhtml_hi_limit={args["--line-hi"]}',
        f'--rc genhtml_med_limit={args["--line-med"]}',
    ])
    cmd = f'genhtml {srcfile} -o {html_dir} {GENHTML_OPTS} {limits}'
    print_output( cmd, VERBOSE_ONLY )
    (r, text) = utils2.run_shell( cmd )
    if r != 0:
        sys.exit(text)

def print_summary( srcfile ):
    cmd = f'{lcov()} --summary {srcfile} {LCOV_OPTS}'
    print_output( cmd, VERBOSE_ONLY )
    (r, out) = utils2.run_shell( cmd )
    if r != 0:
        sys.exit(out)
    print_output( out )

def lcov():
    # Windoze is special
    if platform.system().lower() == 'windows':
        return 'lcov.pl'
    return 'lcov'

#------------------------------------------------------------------------------
def open_html_in_browser( html_file_path ):
    """Open an HTML file in the default browser on both Linux and Windows"""
    system = platform.system().lower()
    
    if system == 'linux':
        cmd = f'xdg-open "{html_file_path}"'
    elif system == 'windows':
        cmd = f'start "" "{html_file_path}"'
    else:
        # Fallback for other systems (macOS, etc.)
        cmd = f'open "{html_file_path}"'
    
    print_output( f'Opening browser: {cmd}', VERBOSE_ONLY )
    (r, text) = utils2.run_shell( cmd )
    if r != 0:
        print_output( f'Warning: Failed to open browser. Error: {text}' )
        print_output( f'Please manually open: {html_file_path}' )

#------------------------------------------------------------------------------
def derive_unit_test_dir( pkg_root, prj_dir, test_dir ):
    pkg_root = utils2.standardize_whole_path( pkg_root, '/' )
    prj_dir = utils2.standardize_whole_path( prj_dir, '/' )
    test_dir = utils2.standardize_whole_path( test_dir, '/' )
    
    dir_under_test = prj_dir
    if not test_dir.endswith(os.sep):
        test_dir += os.sep
    test_dir_index = dir_under_test.find(test_dir.rstrip(os.sep))
    if test_dir_index != -1:
        dir_under_test = dir_under_test[:test_dir_index]
    dir_under_test = dir_under_test.replace(pkg_root, '')
    if dir_under_test.startswith(os.sep):
        dir_under_test = dir_under_test[1:]
    return dir_under_test

def print_output( output, verbose_only=False ):
    if verbose_only and not verbose_enabled:
       return
    print(output)

